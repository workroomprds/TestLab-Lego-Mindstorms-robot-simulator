package {	// Mindstorms robot simulator - will respond to colour by moving	// should be used as a baseclass to a symbol that needs buttons called rightArrow, leftArrow, goButton, and a tansparent clip called sensor	// needs a colour board. Note - needs clear space to sense	// Updated to sense via sensor, and to turn around 0,0 with updated scripts...	// Updatd to put colur detect and sensor in sensor clip / class	// should be able to set script separately?	// - allow external scripting	// - include tests	// - deal with "say"	import flash.display.Sprite;	import flash.display.Shape;	import flash.display.MovieClip;	import flash.events.MouseEvent;	import flash.events.Event;	import colourSensor;	//	public dynamic class colourRobotObject extends Sprite {		public var state:String;		public var driveStep:Number;		public var rotStep:Number;		public var scripts:Array;		public var moveScript:Array;		public var beingDragged:Boolean;		public var draggableWhileMoving:Boolean;		// declare stage instances - do I need "this." if they're declared here? Or should I use "this." and not declare them here?			public var rightArrow:MovieClip; // or sprite, or *, or shape? --- also, can I use "internal"			public var leftArrow:MovieClip;			public var goButton:MovieClip;			public var sensor:colourSensor;		//		public function colourRobotObject(){			this.driveStep = 5;			this.rotStep = 10;			stopMe();			setUpScripts();			this.beingDragged = false;			this.draggableWhileMoving = true; // compile-time option			this.addEventListener(Event.ENTER_FRAME, takeAction);			this.addEventListener(MouseEvent.MOUSE_DOWN, mouseDownHandler);			this.addEventListener(MouseEvent.MOUSE_UP, mouseUpHandler);			this.addEventListener(MouseEvent.MOUSE_OUT, mouseUpHandler);			rightArrow.addEventListener(MouseEvent.MOUSE_DOWN, rightArrowBtn);			leftArrow.addEventListener(MouseEvent.MOUSE_DOWN, leftArrowBtn);			goButton.addEventListener(MouseEvent.MOUSE_DOWN, doSensing);		}		private function stopMe(){			this.state = "Still";		}		private function rightArrowBtn(e:Event){			this.rotation += rotStep;		}		private function leftArrowBtn(e:Event){			this.rotation -= rotStep;		}		// called each frame		private function takeAction(e:Event):void {			if (this.state == "followingScript" && !this.beingDragged) {				followScript();			}		}		private function mouseDownHandler(evt:MouseEvent):void{			if (this.draggableWhileMoving || (this.state != "followingScript")){				this.beingDragged = true;				startDrag();					}		}		private function mouseUpHandler(evt:MouseEvent):void{			if (this.beingDragged){				this.beingDragged = false;				stopDrag();					}		}		private function doSensing(e:Event) { // note - if dropped mid-turn, this will do a sense on drop			if (!this.beingDragged) {				senseAndScript();			}		}		private function senseAndScript() {			var groundColour:String = sensor.senseStuff();			say(groundColour);			if (this.scripts[groundColour]) {				doScript(groundColour); 			}		}				private function doScript(scriptName:String) {			moveScript = clone(scripts[scriptName]); // make a copy of the script (for now...)			state = "followingScript"; 		}		private function say(word:String) {			//trace(word);			//speechBubble.info.text = word;		}		private function followScript() {			// cope with backwards by sensing direction, avoid /0 problem			var driveDir:Number = (moveScript[0].drive != 0) ? (moveScript[0].drive / Math.abs(moveScript[0].drive)) : 0; // -1 or 1			var rotDir:Number = (moveScript[0].rot != 0) ? (moveScript[0].rot / Math.abs(moveScript[0].rot)) : 0; // -1 or 1			//			// make the move ---- could I use a tween?			if (moveScript[0].drive != 0) { // pointles efficiency here?				var step:Number = driveDir*Math.min(Math.abs(this.driveStep) , Math.abs(moveScript[0].drive)) ; // cope with fractional step				this.y -= step * Math.cos(rotation * Math.PI/180); // !! note - sign; remember 0 is top right, not bottom right				this.x += step * Math.sin(rotation * Math.PI/180);				moveScript[0].drive -= step;			}			// turn  ---- could I use a tween?			if (moveScript[0].rot != 0 ) {				var stepAngle:Number = rotDir*Math.min(Math.abs(this.rotStep) , Math.abs(moveScript[0].rot)) ; // cope with fractional step				this.rotation += stepAngle;				moveScript[0].rot -= stepAngle;							}			// if there's nothing left to do, throw away the step ---- surely there's a neater way to do this?			if (moveScript[0].drive == 0 && moveScript[0].rot == 0) {				moveScript.shift();			}			// if there's no steps left, look at the floor			if (moveScript[0] == null) {				stopMe();				senseAndScript();			} 		}		private function setUpScripts() {			// Scripts can be arbitrary length, involve turns as same time as drives, turn either way, drive either way			var longStep:Number = 50; 									// good if it matches board checker size			var resetStep:Number = this.y-this.sensor.y;				// Note: not sensitive to a sensor on the x-axis, nor to a resized robot.			var moveToSensor0:Object = {drive: resetStep, rot: 0}; 		// to move the axis of rotation (turning point) to sensor location			var moveFromSensor0:Object = {drive: -resetStep, rot: 0}; 	// to move the axis of rotation away from the sensed location			var foreward:Object = {drive: longStep, rot: 0};				var backward:Object = {drive: -longStep, rot: 0};			var turnLeft:Object = {drive: 0, rot: -90};			var turnRight:Object = {drive: 0, rot: 90};			var turnRound:Object = {drive: 0, rot: 180};			this.scripts = new Array;			this.scripts["Blue"] = 		new Array(moveToSensor0, turnLeft, moveFromSensor0, backward);			this.scripts["Red"] = 		new Array(moveToSensor0, turnRight, moveFromSensor0, foreward);			this.scripts["Green"] =		new Array(moveToSensor0, turnRight, moveFromSensor0, backward);			this.scripts["Yellow"] =	new Array(moveToSensor0, turnRound, moveFromSensor0, foreward);			this.scripts["Black"] =		new Array(moveToSensor0, turnLeft, moveFromSensor0, foreward);		}		// from http://help.adobe.com/en_US/ActionScript/3.0_ProgrammingAS3/WS5b3ccc516d4fbf351e63e3d118a9b90204-7ee7.html		// used to clone a script array so it can be consumed rathre than tracked through		import flash.utils.ByteArray; // for the clone method		private function clone(source:Object):* 		{ 		    var myBA:ByteArray = new ByteArray(); 		    myBA.writeObject(source); 		    myBA.position = 0; 		    return(myBA.readObject()); 		}	}}/*///// just to see about testinginternal function testMeInternal() {	trace("internal function accessed");}private function testMePrivate() {	trace("private function accessed");}public function testMePublic() {	trace("public function accessed");}*/// called when added to stage//function justAdded(e:Event):void {//	removeEventListener(Event.ADDED_TO_STAGE, justAdded);//	trace("Added to stage! I am "+state);////}// curved paths//this won't work, because it trundles in a straight line a bit after turning. driveStep for an arc needs to be reduced if we want to turn on radius 50//var longArc:Number = Math.PI*longStep/2;					// if longStep is the radius, this is the circumifrence of a quarter//var rightBend:Object = {drive: longArc, rot: 90};//var leftBend:Object = {drive: longArc, rot: -90};//var circle:Object = {drive: 2*longArc, rot: 360}; //!!//this.scripts["Blue"] = new Array(moveToSensor0, circle, moveFromSensor0);